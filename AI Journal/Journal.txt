AI Usage Journal
Ryan Gaffney
Section 0203
rgaffney@terpmail.umd.edu

Week 1:
This week I used AI mainly for debugging and I used my previous work from another class to look at and see what put down for a simmilar question to see if I can answer 
the question without using AI to answer it for me. I tried out Claude AI for the first time and wanted to try and see how it  differs from ChatGPT to see if the results can be 
different or simmilar in any capacity. From what I found is that the results usually were the same if you just copied and pasted the question in there and nothing else. Even though 
it does practially give you the same answer Claude does try to explain the code and results in greater detail rather ChatGPT just gives a short description of both 
the code and the results.

Claude: https://claude.ai/share/b907db96-3c44-4449-885d-9b5384dca2d1
ChatGPT: https://chatgpt.com/share/68c78ec2-408c-8004-8047-5195e42889c5

Week 2: 
This week I didn’t use AI to complete the assignment itself, but I thought about
how it could be useful for creating practice questions that explain concepts 
with small examples. Since our focus was on conditionals, loops, and lists, 
I could have asked AI to give me prompts like these:

- Describe how a while loop is different from a for loop, 
with an example that runs until a counter reaches 5.

- Show how to combine a loop and a conditional, 
with an example that prints only the even numbers from [2, 3, 5, 8, 10].

Using AI this way would help me think about the concepts more clearly and 
give me extra practice problems, but I made sure to work through the actual 
assignment on my own.

https://claude.ai/share/fe0d2e05-7c4a-4f44-8beb-630c7af8b195



Week 3:
This week I didn't use any AI for this weeks assignment but I did have questions pretaining to this weeks material
- What does it mean that the argument expression is evaluated before the function is invoked?
- What happens if a function ends without a return statement or with a return but no expression?

1. Argument expressions evaluated before function invocation
Python calculates the values of any arguments first.
Only after that does it hand those values into the function.
Example: print_twice(3+4) → 3+4 becomes 7 before the function runs.

2. Function ending without a return (or with a bare return)
If no return is given, or if return has no value, the function returns None.
This is the default behavior for all “void” functions.

https://claude.ai/share/62d72246-35c0-44de-aab6-9faf0dc7f386



Week 4: 
This week I didn't use any AI at all for this week's assignment but I did have some questions based on class design & attributes 
1. How do you decide which attributes belong in a class versus being passed as parameters to its methods?
2. When initializing an object, how should default values for attributes be handled, and when is it better to require explicit values?
3. What are the implications of making an attribute mutable (like a list or dictionary) in a class?

1. Attributes vs Parameters:
    - Attributes store an object’s persistent state or identity.
    - Parameters are for temporary, method-specific values.
2. Default Values vs Required Values:
    - Use defaults for optional or common starting values.
    - Require explicit values for essential attributes that define the object.
3. Mutable Attributes:
    - Mutable attributes (lists, dicts) can change, which is useful but can cause unintended side effects.
    - Always initialize mutable attributes in __init__ to give each object its own copy.

https://claude.ai/share/2b075e44-c64d-4308-a9a6-30ba2ad34ffe



Week 5:
I used AI this week for some quesitons I had about understanding encapsulation and data integrity 

1. Maintaining Data Integrity:
Encapsulation protects an object’s internal state by controlling access to its attributes. Using getters, setters, or properties:
- Controls modifications through validation logic.
- Enforces consistency so attributes remain in valid states.
- Pevents invalid states by restricting direct changes.
- Centralizes control for easier maintenance.

2. Input Validation with Encapsulation:
Encapsulation allows automatic validation whenever an attribute is modified.
- Type checking ensures the value is the correct type.
- Range validation prevents illogical values (e.g., negative balances).
- Business rules like “cannot overdraw account” are enforced.

3. Returning Copies in Read-Only Properties:
- Returning a copy of a list or a tuple prevents external code from bypassing encapsulation:
    - Without a copy, users can mutate internal lists even without a setter.
    - Returning a copy or tuple ensures:
        - True encapsulation
        - Enforced validation through controlled methods
        - Predictable behavior
        - Better thread safety

https://claude.ai/share/0effd50e-e0b5-4151-aa57-30f4aa157545




Week 6:
I used AI for some questions I had pretaining to this weeks material.
1. When would you choose a static method over a module-level function? What are the trade-offs? 
2. What happens when you override a class method in a subclass? 

1. Static Method vs Module-Level FunctionWhen to Choose Static Methods:Use static methods when:
    - The function is logically related to a class but doesn't need instance or class data
    - You want to organize code by grouping related utilities with a class
    - You're building a class-based API where discoverability matters
    - You want to enable inheritance/overriding of the utility function
    - The function operates on data types specific to that class domain 

1. When to Choose Module-Level Functions:
    - The function is truly independent and doesn't belong to any particular class
    - You want simpler, more Pythonic code (preferred by PEP 8)
    - You need faster execution (no method call overhead)
    - You're following a functional programming style

2. Overriding Class Methods in Subclasses
- When you override a class method, it follows normal method resolution order (MRO), but the method still receives the calling class (not the defining class) as its first argument.

2. Key Behaviors:
    - cls refers to the calling class, not where the method is defined
    - Class variables are separate between parent and child (no sharing unless explicitly accessed)
    - MRO determines which method runs (child method shadows parent)
    - Can call parent implementation using super()

2. Common Use Cases:
    - Factory methods that return instances of the calling class
    - Configuration methods that modify class-level settings
    - Alternative constructors that need to respect subclass types




Week 7:
I used AI for some questions I had pretaining to this weeks material.
1. Are there any constraints on using try/except blocks within methods that interact with files or databases?
2. When validating data (like ISBNs or user IDs), do we raise exceptions or return error messages that the UI handles?

1. Summary of Constraints:
    - Always ensure cleanup: use with statements or finally blocks
    - Be specific: catch only exceptions you expect and can handle
    - Don't silence errors: if you can't fix it, let it propagate
    - Use context managers: they handle cleanup automatically
    - Consider atomicity: database transactions should succeed or fail together

2. Why Raise Exceptions in Core Logic?
    - Separation of concerns: Library classes handle business logic, UI handles presentation
    - Flexibility: Same library code works with different UIs (CLI, GUI, web)
    - Cannot be ignored - Exceptions force the caller to handle errors
    - Clear flow: Normal code path vs. error path are distinct

https://claude.ai/share/a5bf50f0-ae9c-414a-81f8-da329cc5202a




Week 8:
I used AI for some questions I had pretaining to this weeks assignment.
1. How does using polymorphism (via methods like late_fee() and checkout_message()) improve the flexibility of the LoanDesk class compared to using if/elif conditionals for each book type?
2. When designing subclasses like EBook or ReferenceBook, how do you decide whether to override an existing method (e.g., loan_period_days()) versus creating a new one (e.g., download_link())?

1. Polymorphism vs. If/Elif Chains:
    - Flexibility: Polymorphism lets each subclass define its own behavior (e.g., checkout_message()), so LoanDesk doesn’t need if/elif statements for each book type.
    - Extensibility: You can add new subclasses (like AudioBook) without modifying existing code.
    - Maintainability: Each class controls its own logic — changes in EBook don’t affect others.
    - Open/Closed Principle: Code is open for extension but closed for modification.

2. When to Override vs. Create New Methods
    - Override when the behavior is conceptually shared across all types but implemented differently (e.g., loan_period_days() varies per book type).
    - Create new methods when functionality is unique to one subtype (e.g., EBook.download_link() applies only to digital books).
    - Guidelines:
        - Ask “Is this a general behavior that all subclasses share?” → Override.
        - Ask “Is this unique to this type?” → Create a new method.

https://claude.ai/share/010988e4-b502-4332-8ea2-792a1133de19
